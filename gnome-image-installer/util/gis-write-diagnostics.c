/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
/*
 * Copyright Â© 2018 Endless Mobile, Inc.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include "gis-write-diagnostics.h"

typedef struct {
    gchar *eos_diagnostics_exe;
    GFile *image_dir;
    gchar *home_dir;
} WriteDiagnosticsData;

static WriteDiagnosticsData *
write_diagnostics_data_new (const gchar *eos_diagnostics_exe,
                            GFile       *image_dir,
                            const gchar *home_dir)
{
  WriteDiagnosticsData *d = g_new (WriteDiagnosticsData, 1);
  d->eos_diagnostics_exe = g_strdup (eos_diagnostics_exe ?: "eos-diagnostics");
  d->image_dir = image_dir != NULL ? g_object_ref (image_dir) : NULL;
  d->home_dir = g_strdup (home_dir);
  return d;
}

static void
write_diagnostics_data_free (WriteDiagnosticsData *d)
{
  g_free (d->eos_diagnostics_exe);
  g_clear_object (&d->image_dir);
  g_free (d->home_dir);
  g_free (d);
}

static GBytes *
get_diagnostics (WriteDiagnosticsData *d,
                 GCancellable *cancellable,
                 GError **error)
{
  g_autoptr(GSubprocess) subprocess =
    g_subprocess_new (G_SUBPROCESS_FLAGS_STDOUT_PIPE, error,
                      d->eos_diagnostics_exe, "stdout", NULL);
  g_autoptr(GBytes) stdout_buf = NULL;

  if (subprocess != NULL &&
      g_subprocess_communicate (subprocess,
                                NULL /* stdin_buf */,
                                cancellable,
                                &stdout_buf,
                                NULL /* stderr_buf */,
                                error) &&
      g_subprocess_wait_check (subprocess, cancellable, error))
    return g_steal_pointer (&stdout_buf);

  return NULL;
}

static gboolean
write_diagnostics_in_dir (GTask *task,
                          GFile *dir,
                          const gchar *basename,
                          GBytes *diagnostics,
                          GCancellable *cancellable,
                          GError **error)
{
  g_autoptr(GFile) target = g_file_get_child (dir, basename);
  gsize size = 0;
  gconstpointer data = g_bytes_get_data (diagnostics, &size);

  if (g_file_replace_contents (target, data, size, NULL, FALSE,
                               G_FILE_CREATE_NONE, NULL, cancellable, error))
    {
      g_task_return_pointer (task, g_steal_pointer (&target), g_object_unref);
      return TRUE;
    }

  return FALSE;
}

static void
write_diagnostics_thread_func (GTask *task,
                               gpointer source_object,
                               gpointer task_data,
                               GCancellable *cancellable)
{
  WriteDiagnosticsData *d = task_data;
  g_autoptr(GError) error = NULL;

  /* Grab diagnostics */
  g_autoptr(GBytes) diagnostics = get_diagnostics (d, cancellable, &error);
  if (diagnostics == NULL)
    {
      g_task_return_error (task, g_steal_pointer (&error));
      return;
    }

  /* Generate a filename matching those generated by eos-diagnostics. We build
   * the filename ourselves rather than letting eos-diagnostics do it because:
   * 1. we need to try two different target directories
   * 2. eos-diagnostics prints other text beside the output path
   */
  g_autoptr(GDateTime) now = g_date_time_new_now_local ();
  g_autofree gchar *now_str = g_date_time_format (now, "%y%m%d_%H%M%S_UTC%z");
  g_autofree gchar *output_basename = g_strdup_printf ("eos-diagnostics-%s.txt",
                                                       now_str);
  g_autofree gchar *output = NULL;

  /* Ideally, we want to store the diagnostics to the live medium, in a
   * location which is easily found on both Windows and Linux. The ideal place
   * is the partition where the image is. This will fail if the image is on an
   * ISO, since the ISO filesystem is read-only. It's also possible that the
   * problem we hit is that we couldn't find the image partition!
   */
  if (d->image_dir != NULL)
    {
      if (write_diagnostics_in_dir (task, d->image_dir, output_basename,
                                    diagnostics, cancellable, &error))
        return;

      if (d->home_dir != NULL &&
          !g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_ROFS))
        {
          g_autofree gchar *image_dirname = g_file_get_path (d->image_dir);
          g_message ("failed to write diagnostics to %s: %s",
                     image_dirname, error->message);
        }
    }

  /* Otherwise, save to the user's home directory. Unfortunately, this is a
   * tmpfs (when running from the FBE, it's in /run; in a live user session,
   * /home is a tmpfs).
   *
   * The additional complication is that, when running from the FBE, the user
   * can't get to a file manager or web browser. So there's only any point in
   * saving a log if the user can view it directly from the error page. (In
   * particular, eosinstaller images do not include any GUI text
   * editor; so, in that case, if we couldn't save to the image partition we
   * should just give up.)
   */
  if (d->home_dir != NULL)
    {
      g_autoptr(GFile) home_dir = g_file_new_for_path (d->home_dir);
      g_clear_error (&error);
      if (write_diagnostics_in_dir (task, home_dir, output_basename,
                                    diagnostics, cancellable, &error))
        return;
    }

  if (error != NULL)
    g_task_return_error (task, g_steal_pointer (&error));
  else
    g_task_return_pointer (task, NULL, NULL);
}

/**
 * gis_write_diagnostics_async:
 * @eos_diagnostics_exe: (optional): executable to run to collect diagnostics
 *  (default: "eos-diagnostics" in $PATH)
 * @image_dir: (nullable): root directory of image partition, or %NULL if not
 *  known
 * @home_dir: (nullable): path to home directory, or %NULL if diagnostics
 *  should not be written to the home directory
 *
 * Writes diagnostics produced by @eos_diagnostics_exe to the first of
 * @image_dir and @home_dir which is not %NULL and writable.
 */
void
gis_write_diagnostics_async (const gchar        *eos_diagnostics_exe,
                             GFile              *image_dir,
                             const gchar        *home_dir,
                             GCancellable       *cancellable,
                             GAsyncReadyCallback callback,
                             gpointer            user_data)
{
  g_autoptr(GTask) task = NULL;
  WriteDiagnosticsData *d =
    write_diagnostics_data_new (eos_diagnostics_exe, image_dir, home_dir);

  task = g_task_new (NULL, cancellable, callback, user_data);
  g_task_set_task_data (task, d, (GDestroyNotify) write_diagnostics_data_free);
  g_task_run_in_thread (task, write_diagnostics_thread_func);
}

/**
 * gis_write_diagnostics_finish:
 *
 * Returns: (transfer full) (nullable): the written diagnostics file; or %NULL
 *  with @error set if writing diagnostics to one of the provided directories
 *  failed; or %NULL with @error unset if neither candidate directory was
 *  provided.
 */
GFile *
gis_write_diagnostics_finish (GAsyncResult *result,
                              GError      **error)
{
  return g_task_propagate_pointer (G_TASK (result), error);
}
